Playwright - 

 # Playwright is an open source automation testing framework for reliable
   end-to-end testing for modern web apps.
 
 # It supports many languages such nodejs, javascript, typescript, .NET, Java
   and python,etc.
   
 # It supports all modern browsers such as Chrome, WebKit(Safari Engine), Firefox,etc.
 
 # It is cross platform means, you can use it on Windows, MacOS, Linux,
   locally or on CI, headless or headed.
   
 # It supports device emulation for mobile coverage.
   For e.g. Google Chrome for Android
   
 # It implements "auto-wait" (no artificial timeouts) and "auto retry"
   (web assertions), eliminating key causes for flaky tests.
   (We have/had to add Waits manually to avoid tests to fail due to synchronization
    issue)
    (Due to auto-wait, test execution will wait until condition is not true)
 
 # It has rich tooling options such as tracing, time-travel,etc which makes it
   easy to debug and fix issues.
   
 # It allows multipe tabs, so we can easily switch between the windows.
 
 # Playwright creates a browser context for each test. It means every test runs
   in its own BrowserContext.
   
 # Playwright provides powerful tooling. Some of them are - 
   1.Codegen - Generate tests by recording your action. You can use them in any language.
   
   2.Playwright Inspector - Inpsects pages, generate selectors, step through the test execution,
                            see click points, explore execution logs.
   
   3. Trace Viewer - Captures all the information to investigate test failure. It contains
                     i. test execution screencast
                     ii. live DOM snapshots
                     iii. action explorer
                     iv. test source, etc.

Text after playwright installation -

Inside that directory, you can run several commands:

  npx playwright test
    Runs the end-to-end tests.

  npx playwright test --ui
    Starts the interactive UI mode.

  npx playwright test --project=chromium
    Runs the tests only on Desktop Chrome.

  npx playwright test example
    Runs the tests in a specific file.

  npx playwright test --debug
    Runs the tests in debug mode.

  npx playwright codegen
    Auto generate tests with Codegen.
  
  npx playwright test --headed
    browser opens visibly on your screen.
    used mainly for debugging.

We suggest that you begin by typing:

    npx playwright test

And check out the following files:
  - .\tests\example.spec.js - Example end-to-end test
  - .\playwright.config.js - Playwright Test configuration

Visit https://playwright.dev/docs/intro for more information. ‚ú®

Happy hacking! üé≠

npx playwright show-report
    shows test report in the default browser
    we use this command only when test cases are successful
    otherwise playwright autmatically opens the reports for us
    
npx playwright test tests/example.spec.js
    Only runs the given test, not all of them
    
npx playwright test example
    If you want to run single test without writing the full path
    
npx playwright test -g "My fourth test"
    If you want to run test with test name
    
npx playwright test tests/example.spec.js tests/Dropdown.spe.js
    If you want to run more than one test, but not all of them
    
npx playwright test tests/example.spec.js --project=chromium
    runs only given test only on chrome browser
    
npx playwright test tests/example.test.js --headed
    browser opens visibly only for given test
    
npx playwright test tests/example.spec.js --debug
    Allows you to debug your tests for every browsercontext
    by opening Playwright Inspector to control the tests
    Runs in headed mode automatically.
    
 npx playwright test tests/example.spec.js --debug --headed
    If you want to keep the browser open after debugging
    
 npx playwright codegen --target=csharp
    If you want the code to be generated only in C#.
    Similar for other supported languages as well.
    If you dont give any language, then JavaScript is by default.
    
 npx playwright codegen -b webkit
    If you want the test to open particular browser.
 
 npx playwright codegen www.google.com
    If you want to open a particular website on start.
 
 npx playwright codegen -o tests/newfile.spec.js
    If you want to store the generated code in output directory with file name.
    

‚úî A failed test + successful retry = flaky
‚ùå A failed test + failed retry = failed
‚úî A passed test on first try = passed

Concept	             Meaning in Playwright
Retries	             Automatically re-run failing tests
Flaky Test	         Passed only in retry, unstable
Trace Viewer	     Shows video, DOM snapshots, logs of that retry

Headless (default): Browser is invisible, faster performance.

Headed mode: Real browser window opens, so you can watch interactions
            (clicks, typing, navigation).
            
package.json - It is main json file of playwright which is used to 
              upgrade or downgrade versions of playwright, or add any dependdencies
              to it.
            
playwright.config.js - It is the core file of playwright which is used to make project
                       level changes or project related configurations
                       
codegen - automatic code generator which generates code by recording the 
          actions you perform(click,type,navigate,etc).
          What it does?
          Opens a browser window
          Open the Inspector
          Every action you perform (click, type, navigate‚Ä¶) will generate code automatically.
          After you perform operation, you will see generated code in the inspector.
          
test() - function to declare test

expect() - function to write assertions

page - a fixture which is an isolated instance of Page class. They are isolated between tests.
       Helps in automating the applications
       
BeforeHooks - Setup
AfterHooks - Teardown

Why async/await is important in Playwright?
If you dont write async await for assertions and function inside a
playwright test, playwright's internal auto-wait behaves unpredictably,
which might give you unpredictable or unexpected results.

------------------------------------------------------------------------------------------------------

page.locator() - helps you locate the elements with CSS Selectors or XPath
        If you dont use "//" inside locator(), it assumes that it is CSS Selector.
        for e.g.
        await page.locator("input[name='password']").fill('test@123');
        
        If you use "//", then it assumes the text to be XPath.
        await page.locator("//input[@type='submit']");
        
const browser = await chromium.launch({headless: false}); // use this line for raw playwright script.
In such case, yu have to handle the browser manually.
for e.g. directly using async await without using test() function.
or,
const {chromium} = require('@playwright/test');
(async () => {
const broswer = await chromium.launch();

navigation timeout is different than test timout.
navigation timeout controls methods like,
page.goto
page.click()
page.waitForURL(); ,etc


test.setTimeout(60000); - to manaully set test timeout other than default.
or you can make changes in playwright config file in 'use' config property.

1Ô∏è‚É£ timeout ‚Üí applies to the entire test
2Ô∏è‚É£ expect.timeout ‚Üí applies only to assertions
3Ô∏è‚É£ actionTimeout ‚Üí applies to actions like .click()
4Ô∏è‚É£ navigationTimeout ‚Üí applies only to navigation

-----------------------------------------------------------------------------------

What is a worker?
A worker is a simply a process that runs your tests in parallel.

A worker = 1 parallel test runner.

Each worker:
1.starts its own browser
2.runs tests assigned to it
3.has its own test environment
4.is fully isolated (no data shared with other workers)
5.If a worker crashes, other workers are not affected.

By default:
number of workers = number of CPU cores
so, if your CPU has four cores, then Playwright runs 4 workers

How workers run tests?
Suppose you have 4 test files:
1.login.spec.js
2.signup.spec.js
3.dashboard.spec.js
4.logout.spec.js

And workers = 2.

Worker 1 ‚Üí login.spec.js, dashboard.spec.js
Worker 2 ‚Üí signup.spec.js, logout.spec.js

If you have odd number of test or workers, then Playwright uses parallel sceduling.
for e.g. If you have 2 workers and 11 tests, then 

üîÑ Playwright assigns tests dynamically (one by one)
Step-by-step:

Worker 1 starts running Test 1
Worker 2 starts running Test 2

As soon as any worker finishes, Playwright gives it the next pending test.

Let‚Äôs assume all tests take roughly equal time.

Worker 1 ‚Üí Tests 1, 3, 5, 7, 9, 11 (6 tests)
Worker 2 ‚Üí Tests 2, 4, 6, 8, 10 (5 tests)

But this is not fixed ‚Äî it depends on timing.

If Worker 1 finishes faster, it may run 7 tests.
If Worker 2 finishes faster, it may run more.
----------------------------------------------------------------------

page.pause() - This method
Launches Playwright Inspector automatically
Pauses the test execution at that line
Allows you to:
1.step through the test
2.inspect locators
3.record actions
4.debug the DOM
5.Continues only when you press Resume in the Inspector UI.
 
Note - Inspector appears only in headed mode
If the browser is headless, then:
1.Inspector cannot open 
2.The test may skip pause or fail immediately
3.You may see strange behavior like inspector opening and closing instantly
So you must run in headed mode when using page.pause();

-----------------------------------------------------------------------------------------

page.getByRole() -
This method selects an element according to its ARIA role.

ARIA Role - 
An ARIA role describes what kind of UI element something is, according to accessibility standards.

Examples of roles:

Role	   Meaning
button	   A clickable button
link	   A hyperlink <a> tag
textbox	   An input field
checkbox   A checkbox control
heading	   A heading element

for e.g. -
await page.getByRole('link', { name: 'Logout' }).click();
It means,
‚ÄúFind an element with ARIA role link whose accessible name is Logout.‚Äù

------------------------------------------------------------------------------------------------

Preferred order of using locators(Not Mandatory) (highest ‚Üí lowest)
1.getByRole() ‚Äî Most powerful and accessible
2.getByLabel() ‚Äî For inputs linked to labels
3.getByPlaceholder() ‚Äî For search boxes & input fields
4.getByText() ‚Äî For visible text
5.getByAltText(), getByTitle(), etc.
6.locator() ‚Äî fallback only when above options aren‚Äôt possible
------------------------------------------------------------------------------

Why we write (.flash.error) even though HTML shows class="flash error"?

This is because:
In HTML ‚Üí class names are space-separated
<div class="flash error">...</div>

This element has two separate classes:
1.flash
2.error

In CSS (and Playwright locators) ‚Üí classes are written with dots
The dot (.) means ‚Äúclass selector‚Äù.

So:
In HTML	              In CSS / locator
class="flash"	      .flash
class="error"	      .error
class="flash error"	  .flash.error

Example: How to think about it

HTML:
<div class="flash error">Hello!</div>

Playwright:
page.locator('.flash.error');

CSS:
.flash.error {
  color: red;
}
It means,
Select the <div> that has both classes.

Playwright supports all CSS selector syntax:
.className
#idName
tagName
.class1.class2
div > span
[attribute="value"]

-----------------------------------------------------------------------
Maximizing Window() - 

There is no specific method to maximize the window.
You can set property inside use in playwright config file as, 

   **viewport:null**
You can also customise viewport function. You can change
width and height of the page from viewport function.

you can change it in playwright config by adding 
  *viewport:{width:value in px ,height:value in px}* 
inside use property. This will set height and width for all test script as default.

TO check the dimensions of your page, you can visit below website,
  ** whatismyviewport.com ** 
  Check the screen size after visiting this website.
  
But if you want to change viewport properties only for a particular 
test script, then you can use test.use() function.
for e.g.
test.use({viewport:{width:600,height:600}});

--------------------------------------------------------------------------------------

Screenshots, Video, Tracing -
Those features are set to 'off' by default.
To set them 'on', you can do that inside use property as,
screenshot:on,
trace:on,
video:on

This will set those properties on global level.


The video will be saved automatically in:
test-results/<test-name>/video.webm

----------------------------------------------------------------------------

Playwright cannot select disabled options.
for e.g.
<option value disabled="disabled">select option</option>
await page.locator('#disabled').selectOption({label:"select option"});  // This will fail

Also, you cannot select a dropdown option like clicking normal HTML element
using getByText(). You have to use SelectOptions() method here.
for e.g.
await page.locator('#dropdown').selectOption({value:"1"});

------------------------------------------------------------------------------------------

‚úÖ What is $ in Playwright?

page.$(selector) ‚Üí returns the first matching element (like querySelector in JavaScript).

for e.g.
let option = await page.$('#dropdown');

This finds only the first element that matches the selector
It returns a locator to a single ElementHandle
If no element is found ‚Üí returns null

Note - Now, Playwright recommends using locator over $.

for e.g. Capture first <option> tag inside a dropdown
 let firstOption = await page.locator('#dropdown option').first();
--------------------------------------------------------------------------------------------

‚úÖ What is $$ in Playwright?

page.$$(selector) ‚Üí returns all matching elements (like querySelectorAll in JavaScript).

for e.g.
let allOptions = await page.$$('#dropdown option');

‚úî Returns an array of ElementHandles
‚úî Array may be empty if no match is found

Note - Now, Playwright recommends using locator over $$.

for e.g. Capture all <option> tags inside a dropdown
let allOptions = await page.locator("#dropdown option")

----------------------------------------------------------------------------------------------

Why locator() is preferred over $ or $$ ?

Feature	                      locator()	$$()
Auto-wait	                  ‚úî YES	‚ùå NO
Retries automatically	      ‚úî YES	‚ùå NO
Access nth element	          ‚úî YES	‚úî YES
Returns ElementHandle?	      ‚ùå No	    ‚úî Yes
Recommended by Playwright	  ‚úî YES	‚ùå No

---------------------------------------------------------------------------------

//Selecting Multiple Values from the Dropdown - Only possible if multiple tag is available
<select multiple name="hobbies" id="hobbies">
  <option hidden value="">Select Multiple Hobbies</option>
  <option value="Playing">Playing</option>
  <option value="Reading">Reading</option>
  <option value="Swimming">Swimming</option>
  <option value="Singing">Singing</option>
  <option value="Dancing">Dancing</option>
</select>

As shown in example above you can select multiple options from 
above select tag as it contains style 'multiple'.

----------------------------------------------------------------------------------------------------

module.exports = {
  testMatch: ["**/*.js"]
};

If you add above line in playwright config file, it will treat all .js files as 
test file. But, it should be avoidable.

--------------------------------------------------------------------------------------------------------

page.on() -
page.on() is a Playwright event listener method.
You use page.on() when you want to react to an event automatically, without writing manual waiting or polling.
It allows you to listen for events happening on a Page, such as:

1.console logs
2.network requests
3.dialogs (alerts, prompts)
4.page errors
5.file downloads
6.requests finished
7.responses received
8.navigation events

It works exactly like JavaScript event listeners, but for browser events inside Playwright.

Syntax- 
page.on('<event-name>', callback)

Example - 
page.on('dialog', async(msg) => {
  console.log("Dialog Text:", msg.text());  //or msg.message();
  await msg.accept();  //msg.miss();   To say yes or no to confirm alerts
});

In above example, it will capture the text from the dialog box
when it appears and saves it in msg variable.

Event	          What It Detects
console	          Browser's console.log
pageerror	      JavaScript errors
dialog	          Alerts, confirms, prompts
download	      File downloads
request	          Every network request
response	      Every response
requestfailed	  Request failed
framenavigated	  Navigation inside frames

-----------------------------------------------------------------------------

‚úÖ Preferred Way to Handle frames in Playwright ‚Üí Use frameLocator() (not .frames())

‚úî Stable
‚úî Auto-waiting
‚úî No loops
‚úî No manual frame switching
‚úî Cleaner selectors
‚úî Works even if iframe loads late

This is the modern Playwright-recommended style as per official docs.

-------------------------------------------------------------------------------------------

Meaning of: src*='login?isIframe=true' - 

This is a CSS attribute selector with a wildcard.

‚úî Full form:
iframe[src*="login?isIframe=true"]

This tells Playwright:
‚ÄúSelect the <iframe> whose src attribute contains the text login?isIframe=true anywhere inside it.‚Äù

‚úî Example

If the iframe HTML on the page is:
<iframe src="https://accounts.paytm.com/v1/api/login?isIframe=true&theme=paytm-web"></iframe>

Then:
The src attribute is:
https://accounts.paytm.com/v1/api/login?isIframe=true&theme=paytm-web

The substring login?isIframe=true is inside it.
So it matches.

Why use *= ?

*= means "contains substring".

Other operators exist too:

Selector	Meaning
=	        equals exactly
^=	        starts with
$=	        ends with
*=	        contains anywhere

STEP 1 ‚Äî How to find how many iframes a website has

In Playwright, run:

const allFrames = page.frames();
console.log("Total frames: ", allFrames.length);

for (const f of allFrames) {
  console.log("Frame URL:", f.url());
}

This prints - 
Example Output (Paytm):
Total frames: 3
Frame URL: https://paytm.com/
Frame URL: https://paytm.com/v1/api/login?isIframe=true
Frame URL: about:blank

‚úÖ STEP 2 ‚Äî How to decide which frame you actually need

You choose the frame based on ONE of these:

‚úî 1. The frame URL (most reliable)
If URL contains something like:
/login, /auth, /signin, isIframe=true
It is probably the login iframe.

‚úî 2. Inspect the iframe child elements in browser DevTools
Right-click ‚Üí Inspect ‚Üí find iframe ‚Üí open its DOM.

‚úî 3. Search inside each frame for the element you need
This is very powerful:
for (const frame of page.frames()) {
  const element = await frame.locator("text=Open Paytm App").first();
  if (await element.count()) {
    console.log("Found element in frame:", frame.url());
  }
}

This is a universal solution.

STEP 3 ‚Äî Use the correct selector for the correct frame
Once you identify the correct iframe, use:
üîπ Preferred: frameLocator() approach
Playwright‚Äôs recommended method.

Example (Paytm):

const loginFrame = page.frameLocator("iframe[src*='login?isIframe=true']");
const innerFrame = loginFrame.frameLocator("iframe");

await innerFrame.getByText("Open Paytm App").click();

------------------------------------------------------------------------------------

Context -

context is an spearate isolated environment used for browsing,
has multiple pages, its own cookies, browser specific data.
You can make changes withing than context.

---------------------------------------------------------------------------------------

test.describe() - 
test.describe() is used to group related tests together into a test suite,
 allowing better organization, reporting, and shared setup/teardown hooks.
 
‚úî It creates a test suite
A test suite is a container that groups tests logically.

‚úî Helps organize tests
Suites appear as sections in the HTML report.

‚úî Allows hooks:
beforeAll
beforeEach
afterEach
afterAll

‚úî You can:
tag suites
skip entire blocks
run only that suite
configure fixtures inside a suite
apply different timeouts

Feature	                         For-loop only	   test.describe + For-loop
Groups tests	                 ‚ùå No	           ‚úî Yes
Cleaner report	                 ‚ùå No	           ‚úî Yes
Supports hooks	                 ‚ùå No	           ‚úî Yes
Best for large test suites	     ‚ùå No	           ‚úî Yes
Recommended practice	         ‚ö† Okay	       ‚úî Best

    